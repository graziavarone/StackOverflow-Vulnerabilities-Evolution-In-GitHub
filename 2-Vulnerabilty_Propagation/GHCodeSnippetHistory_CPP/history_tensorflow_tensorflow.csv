,repo,origin_commit,file,code_context,commit_date,line_vuln,code_vuln
0,tensorflow/tensorflow,d90054e7c0f41f4bab81df0548577a73b939a87a,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple     FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname);    Op op_type_;    StringPiece device_, typename_;  ;  // needed for clang  template <typename Op>    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const       // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;      std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs)   return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);",2018-02-07 14:39:49 -0800,345,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
1,tensorflow/tensorflow,7144571f2fc59c8705e4e3d7b922fa0ebf44f3fa,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple     FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname);    Op op_type_;    StringPiece device_, typename_;  ;  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const       // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;      std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs)   return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_); ""' for device type: "",        device);",2018-03-12 19:37:39 -0700,345,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
2,tensorflow/tensorflow,7817237d5852c7778d3ba03c40f139e6f2c37a76,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2018-08-21 16:22:05 -0700,345,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
3,tensorflow/tensorflow,36e1a5ea5ba2dd5eaa7f4cfc84a61f8ce3ea20e1,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple     Op op_type_;  ;  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const       // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      return ret;      // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs)   return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2018-09-11 10:51:01 -0700,355,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
4,tensorflow/tensorflow,6fa6bd045c98bdc89424a3425e15b5161586a9a7,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2018-10-15 11:01:32 -0700,358,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
5,tensorflow/tensorflow,3f23f4ddeabbdc0704444d84c158bd6c348a9f10,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2018-10-15 11:22:32 -0700,355,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
6,tensorflow/tensorflow,52c8bdba0081e4ed428add13e3c0da7ccbfc8f06,tensorflow/core/framework/variant_op_registry.h,,2019-01-26 10:19:26 -0800,314,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
7,tensorflow/tensorflow,063d42680b33321ee8f334b86c7d37cb19ec0281,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2019-06-20 10:29:14 -0700,314,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
8,tensorflow/tensorflow,de37b1eaca05431822223e5c996bc08245cf523b,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2020-01-16 13:11:38 -0800,357,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
9,tensorflow/tensorflow,775a828aade1b87811875ea0ddfa0554c442654b,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2020-02-27 15:42:16 +0900,357,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
10,tensorflow/tensorflow,e8c972652ad77076faf464df4f59240a2dd1548a,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2020-06-23 12:50:42 -0700,357,  UnaryVariantDecodeRegistration(const string& type_name) {  ^
11,tensorflow/tensorflow,a697dbc60433fc8378680716cef9ab363bf70568,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2020-07-31 12:01:59 -0700,357,  UnaryVariantDecodeRegistration(const std::string& type_name) {  ^
12,tensorflow/tensorflow,603a21810f9e129ce86c3c7cc4a6f37586f791b0,tensorflow/core/framework/variant_op_registry.h,"const char* VariantUnaryOpToString(VariantUnaryOp op);
  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple     FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname);    Op op_type_;    StringPiece device_, typename_;  ;  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const       // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;      std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs)   return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);",2021-02-15 23:48:41 -0800,361,  UnaryVariantDecodeRegistration(const std::string& type_name) {  ^
13,tensorflow/tensorflow,39812646c944af98ee9ad1c1ce86eb9d57a1aded,tensorflow/core/framework/variant_op_registry.h,"  // this breaks by falling victim to ""too perfect forwarding""  // see https://stackoverflow.com/questions/44475317/variadic-template-issue  // and references therein  template <typename Op>  struct FuncTuple {    FuncTuple(const Op& op, const StringPiece& dev, const StringPiece& tname)        : op_type_(op), device_(dev), typename_(tname){};    Op op_type_;    StringPiece device_, typename_;  };  //friend declaration for operator==  // needed for clang  template <typename Op>    friend bool operator==(const FuncTuple<Op> &l, const FuncTuple<Op> &r);    template <typename Op>    std::size_t operator()(const FuncTuple<Op>& x) const {      // The hash of an enum is just its value as a std::size_t.      std::size_t ret = static_cast<std::size_t>(x.op_type_);      ret = Hash64Combine(ret, sp_hasher_(x.device_));      ret = Hash64Combine(ret, sp_hasher_(x.typename_));      return ret;    }  std::unordered_map<FuncTuple<VariantUnaryOp>, VariantUnaryOpFn, TupleHash>  std::unordered_map<FuncTuple<VariantBinaryOp>, VariantBinaryOpFn, TupleHash>  // container; return the StringPiece pointing to the permanent string location.template <typename Op>inline bool operator==(const UnaryVariantOpRegistry::FuncTuple<Op>& lhs,                       const UnaryVariantOpRegistry::FuncTuple<Op>& rhs) {  return (lhs.op_type_ == rhs.op_type_) && (lhs.device_ == rhs.device_) &&         (lhs.typename_ == rhs.typename_);}        op, "" Variant type_name: '"", a.TypeName(), ""' for device type: "",        device);",2021-05-26 15:12:46 +0100,362,  UnaryVariantDecodeRegistration(const std::string& type_name) {  ^
