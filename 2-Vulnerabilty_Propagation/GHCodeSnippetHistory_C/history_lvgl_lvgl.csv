,repo,origin_commit,file,code_context,commit_date,line_vuln,code_vuln
0,lvgl/lvgl,1fcda8092ec790df5d2b4ff37e56acd159c40314,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-23 21:28:36 +0100,359,        lv_mem_ent_t * new_e = (lv_mem_ent_t *)&e_data[size]
1,lvgl/lvgl,1fcda8092ec790df5d2b4ff37e56acd159c40314,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-23 21:28:36 +0100,36, uint32_t header
2,lvgl/lvgl,a8ceb6bcaf687199a7f31ab14c818ce43fe29f8d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-24 17:48:47 +0100,360,        lv_mem_ent_t * new_e = (lv_mem_ent_t *)&e_data[size]
3,lvgl/lvgl,a8ceb6bcaf687199a7f31ab14c818ce43fe29f8d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-24 17:48:47 +0100,36, uint32_t header
4,lvgl/lvgl,c48a521882a7c45a4940aef60718f7decccde486,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 11:38:28 +0100,355,        lv_mem_ent_t * new_e = (lv_mem_ent_t *)&e_data[size]
5,lvgl/lvgl,c48a521882a7c45a4940aef60718f7decccde486,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 11:38:28 +0100,95,static inline  void lv_mem_assert(void *p)                                        ^
6,lvgl/lvgl,c48a521882a7c45a4940aef60718f7decccde486,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 11:38:28 +0100,35, uint32_t header
7,lvgl/lvgl,c890dc8d430a131957e4d1b96e552e6d8907c294,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 23:58:05 +0100,355,        lv_mem_ent_t * new_e = (lv_mem_ent_t *)&e_data[size]
8,lvgl/lvgl,c890dc8d430a131957e4d1b96e552e6d8907c294,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 23:58:05 +0100,95,static inline  void lv_mem_assert(void *p)                                        ^
9,lvgl/lvgl,c890dc8d430a131957e4d1b96e552e6d8907c294,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-26 23:58:05 +0100,35, uint32_t header
10,lvgl/lvgl,47f2e0a8f70480ee90c5c9499b962d9dfa8c8738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-30 14:46:16 +0100,95,static inline  void lv_mem_assert(void *p)                                        ^
11,lvgl/lvgl,47f2e0a8f70480ee90c5c9499b962d9dfa8c8738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-11-30 14:46:16 +0100,35, uint32_t header
12,lvgl/lvgl,43646b78ef3021e5a6cf58921d4ece45bf21c8dd,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-03 00:38:30 +0100,94,static inline  void lv_mem_assert(void *p)                                        ^
13,lvgl/lvgl,43646b78ef3021e5a6cf58921d4ece45bf21c8dd,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-03 00:38:30 +0100,36, uint32_t header
14,lvgl/lvgl,562486c14ed906801bfdf4abfb347468f1785154,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-03 22:32:09 +0100,94,static inline  void lv_mem_assert(void *p)                                        ^
15,lvgl/lvgl,562486c14ed906801bfdf4abfb347468f1785154,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-03 22:32:09 +0100,36, uint32_t header
16,lvgl/lvgl,8bd9ab7b84a1d31aca2d24f9463da516579bfcac,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-07 10:38:25 +0100,94,static inline  void lv_mem_assert(void *p)                                        ^
17,lvgl/lvgl,8bd9ab7b84a1d31aca2d24f9463da516579bfcac,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-07 10:38:25 +0100,36, uint32_t header
18,lvgl/lvgl,dfa097058568058d4e0a355c663ecc21319f4713,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-23 09:17:42 +0100,94,static inline  void lv_mem_assert(void *p)                                        ^
19,lvgl/lvgl,dfa097058568058d4e0a355c663ecc21319f4713,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2017-12-23 09:17:42 +0100,36, uint32_t header
20,lvgl/lvgl,8e9335d49fc4c1c8ca92f522fc3476dd562946e7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-06-18 13:51:01 +0300,94,static inline  void lv_mem_assert(void *p)                                        ^
21,lvgl/lvgl,8e9335d49fc4c1c8ca92f522fc3476dd562946e7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-06-18 13:51:01 +0300,34,    uint32_t header
22,lvgl/lvgl,383ce0599e88409376e4b2b72828dabbb7f27cc1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-06-19 09:49:58 +0200,94,static inline  void lv_mem_assert(void *p)                                        ^
23,lvgl/lvgl,383ce0599e88409376e4b2b72828dabbb7f27cc1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-06-19 09:49:58 +0200,34,    uint32_t header
24,lvgl/lvgl,90679c2cf5b81a169c734c41d196c044ea9209b1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-07 11:53:22 +0200,100,static inline  void lv_mem_assert(void *p)                                        ^
25,lvgl/lvgl,90679c2cf5b81a169c734c41d196c044ea9209b1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-07 11:53:22 +0200,33,    uint32_t header
26,lvgl/lvgl,1b9845e38fb0c7bd8322e3321afccb1ed4dc5470,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 06:52:59 +0200,100,static inline  void lv_mem_assert(void *p)                                        ^
27,lvgl/lvgl,1b9845e38fb0c7bd8322e3321afccb1ed4dc5470,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 06:52:59 +0200,57,    MEM_UNIT header
28,lvgl/lvgl,e6516c3a905453259eee0654429a4a772320f738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 11:37:01 +0200,140,"        printf(""e size: %d\n"", e->header.d_size)"
29,lvgl/lvgl,e6516c3a905453259eee0654429a4a772320f738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 11:37:01 +0200,140,"        printf(""e size: %d\n"", e->header.d_size)"
30,lvgl/lvgl,e6516c3a905453259eee0654429a4a772320f738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 11:37:01 +0200,100,static inline  void lv_mem_assert(void *p)                                        ^
31,lvgl/lvgl,e6516c3a905453259eee0654429a4a772320f738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 11:37:01 +0200,58,    MEM_UNIT header
32,lvgl/lvgl,e6516c3a905453259eee0654429a4a772320f738,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 11:37:01 +0200,140,"        printf(""e size: %d\n"", e->header.d_size)"
33,lvgl/lvgl,405acfcbbabb76bd173fcc6807729211d8c4ebb2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 12:24:47 +0200,100,static inline  void lv_mem_assert(void *p)                                        ^
34,lvgl/lvgl,405acfcbbabb76bd173fcc6807729211d8c4ebb2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 12:24:47 +0200,58,    MEM_UNIT header
35,lvgl/lvgl,69434c8b7d81c6c4663a2c253255da36d7d1ec66,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 17:57:08 +0200,58,    MEM_UNIT header
36,lvgl/lvgl,678cbdc23d17c3874205465ebed6dada0c13b2c2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-25 20:39:24 +0200,58,    MEM_UNIT header
37,lvgl/lvgl,39ba305f730c45176057ba5c5134339ebca5a384,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-07-27 06:48:44 +0200,52,    MEM_UNIT header
38,lvgl/lvgl,789532a95f515aa17220555b9e03dd888554d361,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-09-27 15:03:35 +0200,41,    MEM_UNIT header
39,lvgl/lvgl,41695bf9ac758ae3276424e06308e1bb89c4c019,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2018-10-05 17:22:49 +0200,41,    MEM_UNIT header
40,lvgl/lvgl,a883f0b39a93a941ee21e988a43223e666c46d25,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-24 00:14:33 +0200,41,    MEM_UNIT header
41,lvgl/lvgl,1e8ea6b15bea6dbd8c9314d58c70a3ba49f9ac2b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-24 00:14:33 +0200,43,    MEM_UNIT header
42,lvgl/lvgl,eca9245382e31922d3af2f2214926be3069c1e21,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-28 06:09:06 +0100,43,    MEM_UNIT header
43,lvgl/lvgl,f5bd68fa776be80e3b8ac385e9548a811fd4334b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-28 15:18:59 +0100,41,    MEM_UNIT header
44,lvgl/lvgl,0935110284f5877dcf5536f414a313d14f7d3fd6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-28 15:18:59 +0100,43,    MEM_UNIT header
45,lvgl/lvgl,31d0a7f3ae361403c675e55eea556425cff1ca7b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-01-28 15:18:59 +0100,43,    MEM_UNIT header
46,lvgl/lvgl,edb58cc61b1a2ca232a2cd7127194a905de93394,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-03-15 19:41:54 -0400,43,    MEM_UNIT header
47,lvgl/lvgl,f51bf17e39fc637eeaf0a95616f36f6474ea4f2b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-03-17 08:33:03 +0100,43,    MEM_UNIT header
48,lvgl/lvgl,ba2160042a3b61787c3c57c4b4cca210e3dee308,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-04-04 07:15:40 +0200,44,    MEM_UNIT header
49,lvgl/lvgl,6284e3a21bc8bc9f6938594633c61351a8860c3a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-04-12 07:22:37 +0200,44,    MEM_UNIT header
50,lvgl/lvgl,0811096f21ce5df8aa8e748e284c5e742bcee8e7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-04-17 15:00:31 +0200,44,    MEM_UNIT header
51,lvgl/lvgl,56fcd2d1512ccdf9d5207d0b447fe3938723cb85,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-04-22 09:20:04 +0200,44,    MEM_UNIT header
52,lvgl/lvgl,6a265896a233d64387eac70d91b9dd221406d66b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-05-15 07:34:19 +0200,44,    MEM_UNIT header
53,lvgl/lvgl,23f842e46237e51e6cf04349982f616314f95097,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-06-06 06:05:40 +0200,44,    MEM_UNIT header
54,lvgl/lvgl,5d44e66d42360a8c1bb70005288162443ffb5156,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-07-23 08:23:33 +0200,44,    MEM_UNIT header
55,lvgl/lvgl,7f19fb53e6c94eaa2f571481aed36ca6b44d20af,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-10-25 13:37:39 +0200,46,    MEM_UNIT header
56,lvgl/lvgl,b4dae16e22db91d062e9c84177a10f2c581144f7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-11-19 06:25:14 +0100,509,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
57,lvgl/lvgl,b4dae16e22db91d062e9c84177a10f2c581144f7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-11-19 06:25:14 +0100,417,void lv_mem_buf_release(void * p)                               ^
58,lvgl/lvgl,b4dae16e22db91d062e9c84177a10f2c581144f7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-11-19 06:25:14 +0100,47,    MEM_UNIT header
59,lvgl/lvgl,6c8b0c44beacdb1236b35f224d188240b5a9596c,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2019-12-02 12:20:01 +0100,46,    MEM_UNIT header
60,lvgl/lvgl,c7374948a16b94d473879903c1a84ccaf651e511,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-03 18:16:14 +0100,509,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
61,lvgl/lvgl,c7374948a16b94d473879903c1a84ccaf651e511,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-03 18:16:14 +0100,420,void lv_mem_buf_release(void * p)                               ^
62,lvgl/lvgl,c7374948a16b94d473879903c1a84ccaf651e511,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-03 18:16:14 +0100,47,    MEM_UNIT header
63,lvgl/lvgl,c23655a0d7d04b3cfcfd3f0c838dc2933d207ba5,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2019-12-03 18:42:56 +0100,46,    MEM_UNIT header
64,lvgl/lvgl,842283d136ce537ebfc240c6d18b655b2c4c18d9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-06 16:10:04 -0500,46,    MEM_UNIT header
65,lvgl/lvgl,efeec7d3b6ae9d69648eca5f0f75953518f3067b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-09 14:35:13 +0100,46,    MEM_UNIT header
66,lvgl/lvgl,248868fef1f4925fada1aa7591b19e3bc837db51,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-21 23:35:00 +0000,46,    MEM_UNIT header
67,lvgl/lvgl,5a4e069fb890d8cf091dacdfe8bf79b771542b53,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-22 23:19:51 +0100,509,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
68,lvgl/lvgl,5a4e069fb890d8cf091dacdfe8bf79b771542b53,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-22 23:19:51 +0100,435,void lv_mem_buf_release(void * p)                               ^
69,lvgl/lvgl,5a4e069fb890d8cf091dacdfe8bf79b771542b53,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-22 23:19:51 +0100,47,    MEM_UNIT header
70,lvgl/lvgl,47e29bed8e4b4e881fa6cc710968f8ebc4b03a35,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2019-12-22 23:21:09 +0100,46,    MEM_UNIT header
71,lvgl/lvgl,0af0994da17d2181983176943957b79b17dc2e2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-26 22:12:26 +0200,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
72,lvgl/lvgl,0af0994da17d2181983176943957b79b17dc2e2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-26 22:12:26 +0200,439,void lv_mem_buf_release(void * p)                               ^
73,lvgl/lvgl,0af0994da17d2181983176943957b79b17dc2e2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-26 22:12:26 +0200,51,    MEM_UNIT header
74,lvgl/lvgl,0af0994da17d2181983176943957b79b17dc2e2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-26 22:12:26 +0200,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
75,lvgl/lvgl,0af0994da17d2181983176943957b79b17dc2e2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2019-12-26 22:12:26 +0200,20,#include LV_GC_INCLUDE^
76,lvgl/lvgl,bd5f0206f1c46a0b526684f147957dcc8cdab198,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 11:10:07 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
77,lvgl/lvgl,bd5f0206f1c46a0b526684f147957dcc8cdab198,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 11:10:07 +0100,439,void lv_mem_buf_release(void * p)                               ^
78,lvgl/lvgl,bd5f0206f1c46a0b526684f147957dcc8cdab198,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 11:10:07 +0100,51,    MEM_UNIT header
79,lvgl/lvgl,bd5f0206f1c46a0b526684f147957dcc8cdab198,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 11:10:07 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
80,lvgl/lvgl,bd5f0206f1c46a0b526684f147957dcc8cdab198,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 11:10:07 +0100,20,#include LV_GC_INCLUDE^
81,lvgl/lvgl,c668c1731d561ab7b096d1e12a3051897b235f1a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 18:16:20 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
82,lvgl/lvgl,c668c1731d561ab7b096d1e12a3051897b235f1a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 18:16:20 +0100,453,void lv_mem_buf_release(void * p)                               ^
83,lvgl/lvgl,c668c1731d561ab7b096d1e12a3051897b235f1a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 18:16:20 +0100,51,    MEM_UNIT header
84,lvgl/lvgl,c668c1731d561ab7b096d1e12a3051897b235f1a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 18:16:20 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
85,lvgl/lvgl,c668c1731d561ab7b096d1e12a3051897b235f1a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-10 18:16:20 +0100,20,#include LV_GC_INCLUDE^
86,lvgl/lvgl,805af47113b64cb0c55658d7f947ad56558c3567,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-16 14:26:36 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
87,lvgl/lvgl,805af47113b64cb0c55658d7f947ad56558c3567,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-16 14:26:36 +0100,470,void lv_mem_buf_release(void * p)                               ^
88,lvgl/lvgl,805af47113b64cb0c55658d7f947ad56558c3567,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-16 14:26:36 +0100,51,    MEM_UNIT header
89,lvgl/lvgl,805af47113b64cb0c55658d7f947ad56558c3567,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-16 14:26:36 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
90,lvgl/lvgl,805af47113b64cb0c55658d7f947ad56558c3567,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-16 14:26:36 +0100,20,#include LV_GC_INCLUDE^
91,lvgl/lvgl,96e2f879523960540fffc10092a6b92ed70941c7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-21 22:32:25 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
92,lvgl/lvgl,96e2f879523960540fffc10092a6b92ed70941c7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-21 22:32:25 +0100,472,void lv_mem_buf_release(void * p)                               ^
93,lvgl/lvgl,96e2f879523960540fffc10092a6b92ed70941c7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-21 22:32:25 +0100,51,    MEM_UNIT header
94,lvgl/lvgl,96e2f879523960540fffc10092a6b92ed70941c7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-21 22:32:25 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
95,lvgl/lvgl,96e2f879523960540fffc10092a6b92ed70941c7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-21 22:32:25 +0100,20,#include LV_GC_INCLUDE^
96,lvgl/lvgl,eef94325a0c254b0920c106049937ad10f541ebe,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-23 17:16:11 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
97,lvgl/lvgl,eef94325a0c254b0920c106049937ad10f541ebe,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-23 17:16:11 +0100,473,void lv_mem_buf_release(void * p)                               ^
98,lvgl/lvgl,eef94325a0c254b0920c106049937ad10f541ebe,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-23 17:16:11 +0100,51,    MEM_UNIT header
99,lvgl/lvgl,eef94325a0c254b0920c106049937ad10f541ebe,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-23 17:16:11 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
100,lvgl/lvgl,eef94325a0c254b0920c106049937ad10f541ebe,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-01-23 17:16:11 +0100,20,#include LV_GC_INCLUDE^
101,lvgl/lvgl,720322ca9e2d447971fb3ddb1733a3bf3e97883d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-04 02:09:15 +0100,505,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
102,lvgl/lvgl,720322ca9e2d447971fb3ddb1733a3bf3e97883d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-04 02:09:15 +0100,471,void lv_mem_buf_release(void * p)                               ^
103,lvgl/lvgl,720322ca9e2d447971fb3ddb1733a3bf3e97883d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-04 02:09:15 +0100,51,    MEM_UNIT header
104,lvgl/lvgl,720322ca9e2d447971fb3ddb1733a3bf3e97883d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-04 02:09:15 +0100,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
105,lvgl/lvgl,720322ca9e2d447971fb3ddb1733a3bf3e97883d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-04 02:09:15 +0100,20,#include LV_GC_INCLUDE^
106,lvgl/lvgl,63ad3df793dcb0fb9bf9f0e8a0c6f2e465c83299,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-15 14:18:47 -0500,502,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
107,lvgl/lvgl,63ad3df793dcb0fb9bf9f0e8a0c6f2e465c83299,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-15 14:18:47 -0500,472,void lv_mem_buf_release(void * p)                               ^
108,lvgl/lvgl,63ad3df793dcb0fb9bf9f0e8a0c6f2e465c83299,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-15 14:18:47 -0500,51,    MEM_UNIT header
109,lvgl/lvgl,63ad3df793dcb0fb9bf9f0e8a0c6f2e465c83299,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-15 14:18:47 -0500,97,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
110,lvgl/lvgl,63ad3df793dcb0fb9bf9f0e8a0c6f2e465c83299,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-15 14:18:47 -0500,20,#include LV_GC_INCLUDE^
111,lvgl/lvgl,41907f9f3c6c86227085cb7c8b92a756d99d783d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-26 19:48:27 +0100,497,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
112,lvgl/lvgl,41907f9f3c6c86227085cb7c8b92a756d99d783d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-26 19:48:27 +0100,473,void lv_mem_buf_release(void * p)                               ^
113,lvgl/lvgl,41907f9f3c6c86227085cb7c8b92a756d99d783d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-26 19:48:27 +0100,49,    MEM_UNIT header
114,lvgl/lvgl,41907f9f3c6c86227085cb7c8b92a756d99d783d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-26 19:48:27 +0100,94,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
115,lvgl/lvgl,41907f9f3c6c86227085cb7c8b92a756d99d783d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-02-26 19:48:27 +0100,20,    #include LV_GC_INCLUDE^
116,lvgl/lvgl,c51397755910fb4fed4351bbac056642674c1d93,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-03-04 18:10:45 -0500,46,    MEM_UNIT header
117,lvgl/lvgl,3e5275708ef38a36e44af753d06737b1e17f2fcc,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:35:50 +0100,544,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
118,lvgl/lvgl,3e5275708ef38a36e44af753d06737b1e17f2fcc,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:35:50 +0100,483,void lv_mem_buf_release(void * p)                               ^
119,lvgl/lvgl,3e5275708ef38a36e44af753d06737b1e17f2fcc,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:35:50 +0100,49,    MEM_UNIT header
120,lvgl/lvgl,3e5275708ef38a36e44af753d06737b1e17f2fcc,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:35:50 +0100,104,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
121,lvgl/lvgl,3e5275708ef38a36e44af753d06737b1e17f2fcc,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:35:50 +0100,20,    #include LV_GC_INCLUDE^
122,lvgl/lvgl,786e1516617a2028be67e05b26fc29087cc38a96,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:52:48 +0100,544,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
123,lvgl/lvgl,786e1516617a2028be67e05b26fc29087cc38a96,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:52:48 +0100,483,void lv_mem_buf_release(void * p)                               ^
124,lvgl/lvgl,786e1516617a2028be67e05b26fc29087cc38a96,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:52:48 +0100,49,    MEM_UNIT header
125,lvgl/lvgl,786e1516617a2028be67e05b26fc29087cc38a96,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:52:48 +0100,104,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
126,lvgl/lvgl,786e1516617a2028be67e05b26fc29087cc38a96,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 10:52:48 +0100,20,    #include LV_GC_INCLUDE^
127,lvgl/lvgl,9abe6b89cc7610f27b4c058271d73a46de2e27b6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 21:52:53 +0100,544,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
128,lvgl/lvgl,9abe6b89cc7610f27b4c058271d73a46de2e27b6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 21:52:53 +0100,484,void lv_mem_buf_release(void * p)                               ^
129,lvgl/lvgl,9abe6b89cc7610f27b4c058271d73a46de2e27b6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 21:52:53 +0100,49,    MEM_UNIT header
130,lvgl/lvgl,9abe6b89cc7610f27b4c058271d73a46de2e27b6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 21:52:53 +0100,105,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
131,lvgl/lvgl,9abe6b89cc7610f27b4c058271d73a46de2e27b6,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-20 21:52:53 +0100,20,    #include LV_GC_INCLUDE^
132,lvgl/lvgl,68b31008b756c284b5d89031c8ffc341a9be8614,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-23 09:25:04 +0100,544,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
133,lvgl/lvgl,68b31008b756c284b5d89031c8ffc341a9be8614,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-23 09:25:04 +0100,484,void lv_mem_buf_release(void * p)                               ^
134,lvgl/lvgl,68b31008b756c284b5d89031c8ffc341a9be8614,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-23 09:25:04 +0100,49,    MEM_UNIT header
135,lvgl/lvgl,68b31008b756c284b5d89031c8ffc341a9be8614,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-23 09:25:04 +0100,105,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
136,lvgl/lvgl,68b31008b756c284b5d89031c8ffc341a9be8614,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-23 09:25:04 +0100,20,    #include LV_GC_INCLUDE^
137,lvgl/lvgl,bb0c5a968c7a10a0e099376eb341277c186762ef,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-24 10:13:52 +0100,544,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
138,lvgl/lvgl,bb0c5a968c7a10a0e099376eb341277c186762ef,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-24 10:13:52 +0100,484,void lv_mem_buf_release(void * p)                               ^
139,lvgl/lvgl,bb0c5a968c7a10a0e099376eb341277c186762ef,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-24 10:13:52 +0100,49,    MEM_UNIT header
140,lvgl/lvgl,bb0c5a968c7a10a0e099376eb341277c186762ef,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-24 10:13:52 +0100,105,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
141,lvgl/lvgl,bb0c5a968c7a10a0e099376eb341277c186762ef,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-03-24 10:13:52 +0100,20,    #include LV_GC_INCLUDE^
142,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,163,"    printf(""alloc: %d\n"", size)"
143,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,789,"    printf(""%s, size:%d\n"", e->header.s.used == 0 ? ""free"" : ""used"", e->header.s.d_size)"
144,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,545,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
145,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,503,void lv_mem_buf_release(void * p)                               ^
146,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,53,    MEM_UNIT header
147,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
148,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,789,"    printf(""%s, size:%d\n"", e->header.s.used == 0 ? ""free"" : ""used"", e->header.s.d_size)"
149,lvgl/lvgl,6563f2fa0d991f5834deabf936a744fb90f854ea,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-04-14 10:56:40 +0200,20,    #include LV_GC_INCLUDE^
150,lvgl/lvgl,742eb4f6c89c407efd2f5aee6144dae5c4260cb9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-14 11:06:56 +0200,545,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
151,lvgl/lvgl,742eb4f6c89c407efd2f5aee6144dae5c4260cb9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-14 11:06:56 +0200,502,void lv_mem_buf_release(void * p)                               ^
152,lvgl/lvgl,742eb4f6c89c407efd2f5aee6144dae5c4260cb9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-14 11:06:56 +0200,53,    MEM_UNIT header
153,lvgl/lvgl,742eb4f6c89c407efd2f5aee6144dae5c4260cb9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-14 11:06:56 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
154,lvgl/lvgl,742eb4f6c89c407efd2f5aee6144dae5c4260cb9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-14 11:06:56 +0200,20,    #include LV_GC_INCLUDE^
155,lvgl/lvgl,9de260d64829ac93fb83df807f3f6bd3b39cbe08,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-17 10:30:11 +0200,550,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
156,lvgl/lvgl,9de260d64829ac93fb83df807f3f6bd3b39cbe08,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-17 10:30:11 +0200,502,void lv_mem_buf_release(void * p)                               ^
157,lvgl/lvgl,9de260d64829ac93fb83df807f3f6bd3b39cbe08,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-17 10:30:11 +0200,53,    MEM_UNIT header
158,lvgl/lvgl,9de260d64829ac93fb83df807f3f6bd3b39cbe08,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-17 10:30:11 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
159,lvgl/lvgl,9de260d64829ac93fb83df807f3f6bd3b39cbe08,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-17 10:30:11 +0200,20,    #include LV_GC_INCLUDE^
160,lvgl/lvgl,479d31e5a7bc51e17540dcf4564d226cc0f23912,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-23 15:27:51 +0200,550,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
161,lvgl/lvgl,479d31e5a7bc51e17540dcf4564d226cc0f23912,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-23 15:27:51 +0200,502,void lv_mem_buf_release(void * p)                               ^
162,lvgl/lvgl,479d31e5a7bc51e17540dcf4564d226cc0f23912,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-23 15:27:51 +0200,53,    MEM_UNIT header
163,lvgl/lvgl,479d31e5a7bc51e17540dcf4564d226cc0f23912,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-23 15:27:51 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
164,lvgl/lvgl,479d31e5a7bc51e17540dcf4564d226cc0f23912,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-23 15:27:51 +0200,20,    #include LV_GC_INCLUDE^
165,lvgl/lvgl,660d0d600024af682e025b5f12679a20bc2a6ee0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-24 22:02:24 +0200,550,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
166,lvgl/lvgl,660d0d600024af682e025b5f12679a20bc2a6ee0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-24 22:02:24 +0200,505,void lv_mem_buf_release(void * p)                               ^
167,lvgl/lvgl,660d0d600024af682e025b5f12679a20bc2a6ee0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-24 22:02:24 +0200,53,    MEM_UNIT header
168,lvgl/lvgl,660d0d600024af682e025b5f12679a20bc2a6ee0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-24 22:02:24 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
169,lvgl/lvgl,660d0d600024af682e025b5f12679a20bc2a6ee0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-04-24 22:02:24 +0200,20,    #include LV_GC_INCLUDE^
170,lvgl/lvgl,aad8667a9f9dce82f719aec24f64dbe42f729ad0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-01 11:17:43 +0200,551,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
171,lvgl/lvgl,aad8667a9f9dce82f719aec24f64dbe42f729ad0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-01 11:17:43 +0200,507,void lv_mem_buf_release(void * p)                               ^
172,lvgl/lvgl,aad8667a9f9dce82f719aec24f64dbe42f729ad0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-01 11:17:43 +0200,53,    MEM_UNIT header
173,lvgl/lvgl,aad8667a9f9dce82f719aec24f64dbe42f729ad0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-01 11:17:43 +0200,109,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
174,lvgl/lvgl,aad8667a9f9dce82f719aec24f64dbe42f729ad0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-01 11:17:43 +0200,20,    #include LV_GC_INCLUDE^
175,lvgl/lvgl,eaeb362001a4bb8083cf907d513701af73f14472,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-11 10:21:23 +0200,551,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
176,lvgl/lvgl,eaeb362001a4bb8083cf907d513701af73f14472,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-11 10:21:23 +0200,542,void lv_mem_buf_release(void * p)                               ^
177,lvgl/lvgl,eaeb362001a4bb8083cf907d513701af73f14472,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-11 10:21:23 +0200,53,    MEM_UNIT header
178,lvgl/lvgl,eaeb362001a4bb8083cf907d513701af73f14472,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-11 10:21:23 +0200,118,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
179,lvgl/lvgl,eaeb362001a4bb8083cf907d513701af73f14472,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-11 10:21:23 +0200,20,    #include LV_GC_INCLUDE^
180,lvgl/lvgl,97392f4fdf0566583cf67e5d6842f4d7528fe830,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-13 14:11:16 +0200,551,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
181,lvgl/lvgl,97392f4fdf0566583cf67e5d6842f4d7528fe830,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-13 14:11:16 +0200,542,void _lv_mem_buf_release(void * p)                                ^
182,lvgl/lvgl,97392f4fdf0566583cf67e5d6842f4d7528fe830,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-13 14:11:16 +0200,53,    MEM_UNIT header
183,lvgl/lvgl,97392f4fdf0566583cf67e5d6842f4d7528fe830,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-13 14:11:16 +0200,118,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
184,lvgl/lvgl,97392f4fdf0566583cf67e5d6842f4d7528fe830,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-13 14:11:16 +0200,20,    #include LV_GC_INCLUDE^
185,lvgl/lvgl,ee6c5e339940cbf8a0e759fb74095d9ebe4af114,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-18 16:57:23 +0200,554,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
186,lvgl/lvgl,ee6c5e339940cbf8a0e759fb74095d9ebe4af114,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-18 16:57:23 +0200,543,void _lv_mem_buf_release(void * p)                                ^
187,lvgl/lvgl,ee6c5e339940cbf8a0e759fb74095d9ebe4af114,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-18 16:57:23 +0200,53,    MEM_UNIT header
188,lvgl/lvgl,ee6c5e339940cbf8a0e759fb74095d9ebe4af114,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-18 16:57:23 +0200,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
189,lvgl/lvgl,ee6c5e339940cbf8a0e759fb74095d9ebe4af114,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-18 16:57:23 +0200,20,    #include LV_GC_INCLUDE^
190,lvgl/lvgl,72c79b58a8d18d27ac71f5db6a192baa6164924a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-19 10:31:13 +0200,554,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
191,lvgl/lvgl,72c79b58a8d18d27ac71f5db6a192baa6164924a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-19 10:31:13 +0200,543,void _lv_mem_buf_release(void * p)                                ^
192,lvgl/lvgl,72c79b58a8d18d27ac71f5db6a192baa6164924a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-19 10:31:13 +0200,53,    MEM_UNIT header
193,lvgl/lvgl,72c79b58a8d18d27ac71f5db6a192baa6164924a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-19 10:31:13 +0200,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
194,lvgl/lvgl,72c79b58a8d18d27ac71f5db6a192baa6164924a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-05-19 10:31:13 +0200,20,    #include LV_GC_INCLUDE^
195,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
196,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
197,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,531,void _lv_mem_buf_release(void * p)                                ^
198,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,53,    MEM_UNIT header
199,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
200,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
201,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
202,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
203,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
204,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,20,    #include LV_GC_INCLUDE^
205,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
206,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
207,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
208,lvgl/lvgl,a49e7e8295f7b25fce88d4db7b1aad3c0b61be7e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 08:51:22 +0200,281,    new_size = (new_size + 3) & (~0x7                                ^
209,lvgl/lvgl,140904e2017df81c175f33d839ab69f8a933ae4f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 11:03:00 +0200,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
210,lvgl/lvgl,140904e2017df81c175f33d839ab69f8a933ae4f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 11:03:00 +0200,531,void _lv_mem_buf_release(void * p)                                ^
211,lvgl/lvgl,140904e2017df81c175f33d839ab69f8a933ae4f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 11:03:00 +0200,53,    MEM_UNIT header
212,lvgl/lvgl,140904e2017df81c175f33d839ab69f8a933ae4f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 11:03:00 +0200,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
213,lvgl/lvgl,140904e2017df81c175f33d839ab69f8a933ae4f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-02 11:03:00 +0200,20,    #include LV_GC_INCLUDE^
214,lvgl/lvgl,479851e968083a397b84e3bd874d4b1e622704fa,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 13:10:56 +0200,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
215,lvgl/lvgl,479851e968083a397b84e3bd874d4b1e622704fa,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 13:10:56 +0200,530,void _lv_mem_buf_release(void * p)                                ^
216,lvgl/lvgl,479851e968083a397b84e3bd874d4b1e622704fa,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 13:10:56 +0200,53,    MEM_UNIT header
217,lvgl/lvgl,479851e968083a397b84e3bd874d4b1e622704fa,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 13:10:56 +0200,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
218,lvgl/lvgl,479851e968083a397b84e3bd874d4b1e622704fa,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 13:10:56 +0200,20,    #include LV_GC_INCLUDE^
219,lvgl/lvgl,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 20:22:06 +0100,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
220,lvgl/lvgl,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 20:22:06 +0100,543,void _lv_mem_buf_release(void * p)                                ^
221,lvgl/lvgl,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 20:22:06 +0100,53,    MEM_UNIT header
222,lvgl/lvgl,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 20:22:06 +0100,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
223,lvgl/lvgl,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 20:22:06 +0100,20,    #include LV_GC_INCLUDE^
224,lvgl/lvgl,91acf877c680da43ce05ec4a420d2956247ebda8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 21:00:12 +0100,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
225,lvgl/lvgl,91acf877c680da43ce05ec4a420d2956247ebda8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 21:00:12 +0100,543,void _lv_mem_buf_release(void * p)                                ^
226,lvgl/lvgl,91acf877c680da43ce05ec4a420d2956247ebda8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 21:00:12 +0100,53,    MEM_UNIT header
227,lvgl/lvgl,91acf877c680da43ce05ec4a420d2956247ebda8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 21:00:12 +0100,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
228,lvgl/lvgl,91acf877c680da43ce05ec4a420d2956247ebda8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-08 21:00:12 +0100,20,    #include LV_GC_INCLUDE^
229,lvgl/lvgl,ce8d3334074bad89c909ca49c113611f924083ee,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-09 09:46:42 +0100,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
230,lvgl/lvgl,ce8d3334074bad89c909ca49c113611f924083ee,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-09 09:46:42 +0100,543,void _lv_mem_buf_release(void * p)                                ^
231,lvgl/lvgl,ce8d3334074bad89c909ca49c113611f924083ee,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-09 09:46:42 +0100,53,    MEM_UNIT header
232,lvgl/lvgl,ce8d3334074bad89c909ca49c113611f924083ee,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-09 09:46:42 +0100,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
233,lvgl/lvgl,ce8d3334074bad89c909ca49c113611f924083ee,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-09 09:46:42 +0100,20,    #include LV_GC_INCLUDE^
234,lvgl/lvgl,585bc329e68a760f41e1d577dda67b901c2fc776,src/lv_misc/lv_mem.c," * Initialize the dyn_mem module (work memory and other variables)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif",2020-06-15 17:12:48 +0300,571,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
235,lvgl/lvgl,585bc329e68a760f41e1d577dda67b901c2fc776,src/lv_misc/lv_mem.c," * Initialize the dyn_mem module (work memory and other variables)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif",2020-06-15 17:12:48 +0300,530,void _lv_mem_buf_release(void * p)                                ^
236,lvgl/lvgl,585bc329e68a760f41e1d577dda67b901c2fc776,src/lv_misc/lv_mem.c," * Initialize the dyn_mem module (work memory and other variables)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif",2020-06-15 17:12:48 +0300,53,    MEM_UNIT header
237,lvgl/lvgl,585bc329e68a760f41e1d577dda67b901c2fc776,src/lv_misc/lv_mem.c," * Initialize the dyn_mem module (work memory and other variables)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif",2020-06-15 17:12:48 +0300,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
238,lvgl/lvgl,585bc329e68a760f41e1d577dda67b901c2fc776,src/lv_misc/lv_mem.c," * Initialize the dyn_mem module (work memory and other variables)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif",2020-06-15 17:12:48 +0300,20,    #include LV_GC_INCLUDE^
239,lvgl/lvgl,25fbcea31ac448917d8dbeb35d5f5077397ed81d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-18 06:40:39 -0400,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
240,lvgl/lvgl,25fbcea31ac448917d8dbeb35d5f5077397ed81d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-18 06:40:39 -0400,546,void _lv_mem_buf_release(void * p)                                ^
241,lvgl/lvgl,25fbcea31ac448917d8dbeb35d5f5077397ed81d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-18 06:40:39 -0400,53,    MEM_UNIT header
242,lvgl/lvgl,25fbcea31ac448917d8dbeb35d5f5077397ed81d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-18 06:40:39 -0400,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
243,lvgl/lvgl,25fbcea31ac448917d8dbeb35d5f5077397ed81d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-06-18 06:40:39 -0400,20,    #include LV_GC_INCLUDE^
244,lvgl/lvgl,43f5e4d2e0bfe140b37297ac165d40d398052e77,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-07-07 09:36:59 +0200,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
245,lvgl/lvgl,43f5e4d2e0bfe140b37297ac165d40d398052e77,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-07-07 09:36:59 +0200,547,void _lv_mem_buf_release(void * p)                                ^
246,lvgl/lvgl,43f5e4d2e0bfe140b37297ac165d40d398052e77,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-07-07 09:36:59 +0200,53,    MEM_UNIT header
247,lvgl/lvgl,43f5e4d2e0bfe140b37297ac165d40d398052e77,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-07-07 09:36:59 +0200,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
248,lvgl/lvgl,43f5e4d2e0bfe140b37297ac165d40d398052e77,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0/*Allocate a large array to store the dynamically allocated data*/static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];work_mem = (uint8_t *)work_mem_int;#elsework_mem = (uint8_t *)LV_MEM_ADR;#endiflv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;full->header.s.used = 0;/*The total mem size id reduced by the first header and the close patterns */full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-07-07 09:36:59 +0200,20,    #include LV_GC_INCLUDE^
249,lvgl/lvgl,b58f9c602179877222130221646ff7d3f40f445f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-04 09:19:59 +0200,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
250,lvgl/lvgl,b58f9c602179877222130221646ff7d3f40f445f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-04 09:19:59 +0200,547,void _lv_mem_buf_release(void * p)                                ^
251,lvgl/lvgl,b58f9c602179877222130221646ff7d3f40f445f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-04 09:19:59 +0200,53,    MEM_UNIT header
252,lvgl/lvgl,b58f9c602179877222130221646ff7d3f40f445f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-04 09:19:59 +0200,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
253,lvgl/lvgl,b58f9c602179877222130221646ff7d3f40f445f,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-04 09:19:59 +0200,20,    #include LV_GC_INCLUDE^
254,lvgl/lvgl,67d268b3ee114817fb5d6902dc3c52ff01540ace,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-31 09:33:44 +0200,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
255,lvgl/lvgl,67d268b3ee114817fb5d6902dc3c52ff01540ace,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-31 09:33:44 +0200,545,void _lv_mem_buf_release(void * p)                                ^
256,lvgl/lvgl,67d268b3ee114817fb5d6902dc3c52ff01540ace,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-31 09:33:44 +0200,53,    MEM_UNIT header
257,lvgl/lvgl,67d268b3ee114817fb5d6902dc3c52ff01540ace,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-31 09:33:44 +0200,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
258,lvgl/lvgl,67d268b3ee114817fb5d6902dc3c52ff01540ace,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-08-31 09:33:44 +0200,20,    #include LV_GC_INCLUDE^
259,lvgl/lvgl,68058eeff1039caee9fc7e0fd12a7bd7b075f644,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-13 16:41:55 +0200,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
260,lvgl/lvgl,68058eeff1039caee9fc7e0fd12a7bd7b075f644,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-13 16:41:55 +0200,545,void _lv_mem_buf_release(void * p)                                ^
261,lvgl/lvgl,68058eeff1039caee9fc7e0fd12a7bd7b075f644,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-13 16:41:55 +0200,53,    MEM_UNIT header
262,lvgl/lvgl,68058eeff1039caee9fc7e0fd12a7bd7b075f644,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-13 16:41:55 +0200,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
263,lvgl/lvgl,ae452cbc2259f18324b5b3af6abf6c573d153b1e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-16 13:00:53 +0200,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
264,lvgl/lvgl,ae452cbc2259f18324b5b3af6abf6c573d153b1e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-16 13:00:53 +0200,545,void _lv_mem_buf_release(void * p)                                ^
265,lvgl/lvgl,ae452cbc2259f18324b5b3af6abf6c573d153b1e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-16 13:00:53 +0200,53,    MEM_UNIT header
266,lvgl/lvgl,ae452cbc2259f18324b5b3af6abf6c573d153b1e,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-16 13:00:53 +0200,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
267,lvgl/lvgl,f162a4ca2f664a60f56f8d6499f6cfe20730dcc1,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-10-28 14:39:58 +0100,578,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
268,lvgl/lvgl,f162a4ca2f664a60f56f8d6499f6cfe20730dcc1,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-10-28 14:39:58 +0100,517,void _lv_mem_buf_release(void * p)                                ^
269,lvgl/lvgl,f162a4ca2f664a60f56f8d6499f6cfe20730dcc1,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-10-28 14:39:58 +0100,53,    MEM_UNIT header
270,lvgl/lvgl,f162a4ca2f664a60f56f8d6499f6cfe20730dcc1,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-10-28 14:39:58 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
271,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,178,"    printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",    ^"
272,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,187,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
273,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,193,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
274,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,578,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
275,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,538,void _lv_mem_buf_release(void * p)                                ^
276,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,53,    MEM_UNIT header
277,lvgl/lvgl,54fa0dc28be433cb0a8c241b76b9e15290ec3846,src/lv_misc/lv_mem.c,void _lv_mem_init(void) == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-10-28 14:50:42 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
278,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,186,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
279,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,192,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
280,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,578,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
281,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,537,void _lv_mem_buf_release(void * p)                                ^
282,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,53,    MEM_UNIT header
283,lvgl/lvgl,e6738a26178022c19685745cc423d49bedf3256a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-28 14:58:44 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
284,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,186,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
285,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,192,"        printf(""used: %6d (%3d %%), frag: %3d %%, biggest free: %6d\n"",        ^"
286,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,578,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
287,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,537,void _lv_mem_buf_release(void * p)                                ^
288,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,53,    MEM_UNIT header
289,lvgl/lvgl,7a950f18639481bdcf96bdc4676d0798c31334f0,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-10-29 14:51:39 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
290,lvgl/lvgl,4fbc518d6a2b030f80d917ae7986652f390da968,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-10-29 22:46:37 +0100,578,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
291,lvgl/lvgl,4fbc518d6a2b030f80d917ae7986652f390da968,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-10-29 22:46:37 +0100,534,void _lv_mem_buf_release(void * p)                                ^
292,lvgl/lvgl,4fbc518d6a2b030f80d917ae7986652f390da968,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-10-29 22:46:37 +0100,53,    MEM_UNIT header
293,lvgl/lvgl,4fbc518d6a2b030f80d917ae7986652f390da968,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2020-10-29 22:46:37 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
294,lvgl/lvgl,d6dd6199f31e515a8cf93626bdb12abc5d2263c3,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-11-25 12:21:22 -0500,582,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
295,lvgl/lvgl,d6dd6199f31e515a8cf93626bdb12abc5d2263c3,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-11-25 12:21:22 -0500,547,void _lv_mem_buf_release(void * p)                                ^
296,lvgl/lvgl,d6dd6199f31e515a8cf93626bdb12abc5d2263c3,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-11-25 12:21:22 -0500,53,    MEM_UNIT header
297,lvgl/lvgl,d6dd6199f31e515a8cf93626bdb12abc5d2263c3,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2020-11-25 12:21:22 -0500,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
298,lvgl/lvgl,ec124559f651f045a31ab1167d4be719bb493491,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-12-11 18:04:23 +0100,164,"    printf(""alloc:%d\n"", size)"
299,lvgl/lvgl,ec124559f651f045a31ab1167d4be719bb493491,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-12-11 18:04:23 +0100,582,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
300,lvgl/lvgl,ec124559f651f045a31ab1167d4be719bb493491,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-12-11 18:04:23 +0100,531,void _lv_mem_buf_release(void * p)                                ^
301,lvgl/lvgl,ec124559f651f045a31ab1167d4be719bb493491,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-12-11 18:04:23 +0100,53,    MEM_UNIT header
302,lvgl/lvgl,ec124559f651f045a31ab1167d4be719bb493491,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2020-12-11 18:04:23 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
303,lvgl/lvgl,74d19b109cea8418a88e3658c1014b58bf25344b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-16 10:22:13 +0100,582,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
304,lvgl/lvgl,74d19b109cea8418a88e3658c1014b58bf25344b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-16 10:22:13 +0100,529,void _lv_mem_buf_release(void * p)                                ^
305,lvgl/lvgl,74d19b109cea8418a88e3658c1014b58bf25344b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-16 10:22:13 +0100,53,    MEM_UNIT header
306,lvgl/lvgl,74d19b109cea8418a88e3658c1014b58bf25344b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-16 10:22:13 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
307,lvgl/lvgl,01a6bacbd78548e578a957d15b6bce4cc9dd42d1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-18 15:41:22 +0100,582,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
308,lvgl/lvgl,01a6bacbd78548e578a957d15b6bce4cc9dd42d1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-18 15:41:22 +0100,529,void _lv_mem_buf_release(void * p)                                ^
309,lvgl/lvgl,01a6bacbd78548e578a957d15b6bce4cc9dd42d1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-18 15:41:22 +0100,53,    MEM_UNIT header
310,lvgl/lvgl,01a6bacbd78548e578a957d15b6bce4cc9dd42d1,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2020-12-18 15:41:22 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
311,lvgl/lvgl,9c55d77617040ef465b2dcff3f1cb061da1d9848,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-04 17:26:09 +0100,796,    if(e == NULL) e = ent_get_next(NULL)
312,lvgl/lvgl,9c55d77617040ef465b2dcff3f1cb061da1d9848,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-04 17:26:09 +0100,585,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
313,lvgl/lvgl,9c55d77617040ef465b2dcff3f1cb061da1d9848,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-04 17:26:09 +0100,522,void _lv_mem_buf_release(void * p)                                ^
314,lvgl/lvgl,9c55d77617040ef465b2dcff3f1cb061da1d9848,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-04 17:26:09 +0100,53,    MEM_UNIT header
315,lvgl/lvgl,9c55d77617040ef465b2dcff3f1cb061da1d9848,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-04 17:26:09 +0100,123,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
316,lvgl/lvgl,81b13bf3b6219c3b1b05b05209a8449abf7ab84b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-11 14:28:00 +0100,576,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
317,lvgl/lvgl,81b13bf3b6219c3b1b05b05209a8449abf7ab84b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-11 14:28:00 +0100,544,void _lv_mem_buf_release(void * p)                                ^
318,lvgl/lvgl,81b13bf3b6219c3b1b05b05209a8449abf7ab84b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-11 14:28:00 +0100,53,    MEM_UNIT header
319,lvgl/lvgl,81b13bf3b6219c3b1b05b05209a8449abf7ab84b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-11 14:28:00 +0100,122,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
320,lvgl/lvgl,d6ca15a74923f2e86ce1e4ee6ee83bb2bbc887b8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-12 16:13:41 +0100,576,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
321,lvgl/lvgl,d6ca15a74923f2e86ce1e4ee6ee83bb2bbc887b8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-12 16:13:41 +0100,540,void _lv_mem_buf_release(void * p)                                ^
322,lvgl/lvgl,d6ca15a74923f2e86ce1e4ee6ee83bb2bbc887b8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-12 16:13:41 +0100,49,    MEM_UNIT header
323,lvgl/lvgl,d6ca15a74923f2e86ce1e4ee6ee83bb2bbc887b8,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-12 16:13:41 +0100,118,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
324,lvgl/lvgl,bc25998c5b2acc347eade7d3dac29675d81476b8,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-12 19:26:26 +0100,576,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
325,lvgl/lvgl,bc25998c5b2acc347eade7d3dac29675d81476b8,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-12 19:26:26 +0100,528,void _lv_mem_buf_release(void * p)                                ^
326,lvgl/lvgl,bc25998c5b2acc347eade7d3dac29675d81476b8,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-12 19:26:26 +0100,49,    MEM_UNIT header
327,lvgl/lvgl,bc25998c5b2acc347eade7d3dac29675d81476b8,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-12 19:26:26 +0100,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
328,lvgl/lvgl,c9b97feea87b820a68de0b78c6adb61a1527e042,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-17 09:03:31 -0500,576,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
329,lvgl/lvgl,c9b97feea87b820a68de0b78c6adb61a1527e042,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-17 09:03:31 -0500,528,void _lv_mem_buf_release(void * p)                                ^
330,lvgl/lvgl,c9b97feea87b820a68de0b78c6adb61a1527e042,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-17 09:03:31 -0500,49,    MEM_UNIT header
331,lvgl/lvgl,c9b97feea87b820a68de0b78c6adb61a1527e042,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-17 09:03:31 -0500,119,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
332,lvgl/lvgl,1d6d2eb9d94080db9b5ff2855334b5895df28e52,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-01-21 15:18:20 +0100,797,    if(e == NULL) e = ent_get_next(NULL)
333,lvgl/lvgl,1d6d2eb9d94080db9b5ff2855334b5895df28e52,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-01-21 15:18:20 +0100,585,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
334,lvgl/lvgl,1d6d2eb9d94080db9b5ff2855334b5895df28e52,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-01-21 15:18:20 +0100,523,void _lv_mem_buf_release(void * p)                                ^
335,lvgl/lvgl,1d6d2eb9d94080db9b5ff2855334b5895df28e52,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-01-21 15:18:20 +0100,54,    MEM_UNIT header
336,lvgl/lvgl,1d6d2eb9d94080db9b5ff2855334b5895df28e52,src/lv_misc/lv_mem.c,"{
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-01-21 15:18:20 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
337,lvgl/lvgl,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,src/lv_misc/lv_mem.c,#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-23 20:46:42 +0100,797,    if(e == NULL) e = ent_get_next(NULL)
338,lvgl/lvgl,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,src/lv_misc/lv_mem.c,#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-23 20:46:42 +0100,587,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
339,lvgl/lvgl,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,src/lv_misc/lv_mem.c,#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-23 20:46:42 +0100,523,void lv_mem_buf_release(void * p)                               ^
340,lvgl/lvgl,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,src/lv_misc/lv_mem.c,#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-23 20:46:42 +0100,54,    MEM_UNIT header
341,lvgl/lvgl,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,src/lv_misc/lv_mem.c,#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-01-23 20:46:42 +0100,124,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
342,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,756,    if(e == NULL) e = ent_get_next(NULL)
343,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,166,"    printf(""alloc: %d\n"", size)"
344,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,234,"    printf(""free: %d\n"", e->header.s.d_size)"
345,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
346,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
347,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,516,void lv_mem_buf_release(void * p)                               ^
348,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,50,    MEM_UNIT header
349,lvgl/lvgl,07268829c44cb7b040221a2e405dbb2f10289b40,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-01-26 14:12:35 +0100,121,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
350,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,746,    if(e == NULL) e = ent_get_next(NULL)
351,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
352,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
353,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,506,void lv_mem_buf_release(void * p)                               ^
354,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,50,    MEM_UNIT header
355,lvgl/lvgl,e02c7bd415d1ec7b78a6c880059ff1c909dca68d,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-01-26 16:38:21 +0100,121,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
356,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,746,    if(e == NULL) e = ent_get_next(NULL)
357,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
358,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
359,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,506,void lv_mem_buf_release(void * p)                               ^
360,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,50,    MEM_UNIT header
361,lvgl/lvgl,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-04 14:46:11 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
362,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,743,    if(e == NULL) e = ent_get_next(NULL)
363,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
364,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
365,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,503,void lv_mem_buf_release(void * p)                               ^
366,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,50,    MEM_UNIT header
367,lvgl/lvgl,7bec13c2b9b2b624a7c34f71273d6383e6c8202b,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-08 09:53:03 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
368,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,751,    if(e == NULL) e = ent_get_next(NULL)
369,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
370,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
371,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,511,void lv_mem_buf_release(void * p)                               ^
372,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,50,    MEM_UNIT header
373,lvgl/lvgl,e0fb0db735db12fcbeb81c5ae01d9c645845abc2,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-10 22:59:53 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
374,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,748,    if(e == NULL) e = ent_get_next(NULL)
375,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,570,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
376,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,497,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
377,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,508,void lv_mem_buf_release(void * p)                               ^
378,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,50,    MEM_UNIT header
379,lvgl/lvgl,bb08660cb656d094d5ac8cfe31be2e7c7b10c44f,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-02-14 14:56:34 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
380,lvgl/lvgl,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-02-19 13:56:59 +0100,558,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
381,lvgl/lvgl,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-02-19 13:56:59 +0100,485,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
382,lvgl/lvgl,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-02-19 13:56:59 +0100,529,void _lv_mem_buf_release(void * p)                                ^
383,lvgl/lvgl,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-02-19 13:56:59 +0100,50,    MEM_UNIT header
384,lvgl/lvgl,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
void _lv_mem_init(void)#if LV_MEM_CUSTOM == 0#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);",2021-02-19 13:56:59 +0100,120,    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
385,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,752,    if(e == NULL) e = ent_get_next(NULL)
386,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,546,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
387,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,473,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
388,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,512,void lv_mem_buf_release(void * p)                               ^
389,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,50,    MEM_UNIT header
390,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
391,lvgl/lvgl,8004058463a8d4a71f47910e3c6c93653d4f7c50,src/lv_misc/lv_mem.c,#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-24 10:07:54 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
392,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,546,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
393,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,473,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
394,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,511,void lv_mem_buf_release(void * p)                               ^
395,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,50,    MEM_UNIT header
396,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
397,lvgl/lvgl,8c34c1533e65b4b2eb50412b93e25ec8b85e14f9,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-25 14:59:50 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
398,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,575,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
399,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,502,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
400,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,512,void lv_mem_buf_release(void * p)                               ^
401,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,50,    MEM_UNIT header
402,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,121,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
403,lvgl/lvgl,df5a47871d62f4314837e4babab9d4f7e8d49d90,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-02-28 15:02:00 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
404,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,575,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
405,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,502,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
406,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,507,void lv_mem_buf_release(void * p)                               ^
407,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,51,    MEM_UNIT header
408,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,127,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
409,lvgl/lvgl,8bc6931f7f8283017e3584c7c353cb6dd59c1e58,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-02-28 20:42:48 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
410,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,575,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
411,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,502,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
412,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,516,void lv_mem_buf_release(void * p)                               ^
413,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,51,    MEM_UNIT header
414,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,130,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
415,lvgl/lvgl,27025ee6f953778941385f204df68be367c50c2a,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-01 12:02:18 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
416,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,575,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
417,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,502,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
418,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,523,void lv_mem_buf_release(void * p)                               ^
419,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,51,    MEM_UNIT header
420,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,130,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
421,lvgl/lvgl,367e3a31dffcc4be2c6b1d0c19f23c0e7d51a5b2,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;#endif    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);#endif,2021-03-01 15:44:27 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
422,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
423,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,501,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
424,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,519,void lv_mem_buf_release(void * p)                               ^
425,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,51,    MEM_UNIT header
426,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,130,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
427,lvgl/lvgl,47b8893f9942902404e3eb3a4c81c0611fddc25b,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;#else    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns */    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-01 19:31:09 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
428,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
429,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,501,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
430,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,519,void lv_mem_buf_release(void * p)                               ^
431,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,51,    MEM_UNIT header
432,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,130,    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]
433,lvgl/lvgl,ffd9c47d3d06a361d1810122263562c8bce49ab3,src/lv_misc/lv_mem.c,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
",2021-03-03 12:02:58 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
434,lvgl/lvgl,7bf547a9280973e96a21ff9b5165f69051f60c19,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    /*The total mem size id reduced by the first header and the close patterns,2021-03-10 15:13:35 +0100,574,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
435,lvgl/lvgl,7bf547a9280973e96a21ff9b5165f69051f60c19,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    /*The total mem size id reduced by the first header and the close patterns,2021-03-10 15:13:35 +0100,501,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
436,lvgl/lvgl,7bf547a9280973e96a21ff9b5165f69051f60c19,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    /*The total mem size id reduced by the first header and the close patterns,2021-03-10 15:13:35 +0100,309,void lv_mem_buf_release(void * p)                               ^
437,lvgl/lvgl,7bf547a9280973e96a21ff9b5165f69051f60c19,src/lv_misc/lv_mem.c,void _lv_mem_init(void)#if LV_MEM_ADR == 0    /*Allocate a large array to store the dynamically allocated data*/    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    /*The total mem size id reduced by the first header and the close patterns,2021-03-10 15:13:35 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
438,lvgl/lvgl,0cc1e99ddf8768079df5a7d0be3265c54d864174,src/lv_misc/lv_mem.c,void _lv_mem_init(void)    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-16 20:36:27 +0100,575,            lv_opa_t ratio = (uint16_t)((uint16_t)fg_opa * 255) / res_opa_saved
439,lvgl/lvgl,0cc1e99ddf8768079df5a7d0be3265c54d864174,src/lv_misc/lv_mem.c,void _lv_mem_init(void)    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-16 20:36:27 +0100,502,"LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)                                                                               ^"
440,lvgl/lvgl,0cc1e99ddf8768079df5a7d0be3265c54d864174,src/lv_misc/lv_mem.c,void _lv_mem_init(void)    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-16 20:36:27 +0100,309,void lv_mem_buf_release(void * p)                               ^
441,lvgl/lvgl,0cc1e99ddf8768079df5a7d0be3265c54d864174,src/lv_misc/lv_mem.c,void _lv_mem_init(void)    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];    work_mem = (uint8_t *)work_mem_int;    work_mem = (uint8_t *)LV_MEM_ADR;    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;    full->header.s.used = 0;    /*The total mem size id reduced by the first header and the close patterns    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);,2021-03-16 20:36:27 +0100,18,#include LV_ASSERT_HANDLER_INCLUDE^
