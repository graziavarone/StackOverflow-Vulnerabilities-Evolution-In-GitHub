,Unnamed: 0,code_context,code_vuln,commit_date,file,line_vuln,origin_commit,repo
0,0.0,"void dm_init(void)
{
#if DM_CUSTOM == 0
    dm_ent_t * full = (dm_ent_t *)&work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = DM_MEM_SIZE - sizeof(dm_header_t);
#endif
}
",,2017-11-23 20:42:14 +0100,src/lv_misc/lv_mem.c,,c3471fd04e95e7a5d3a4e27d7991d49f42d42845,lvgl/lvgl
1,1.0,"void lv_mem_init(void)
{
#if DM_CUSTOM == 0
    lv_mem_ent_t * full = (lv_mem_ent_t *)&work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = DM_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2017-11-23 21:28:36 +0100,src/lv_misc/lv_mem.c,,1fcda8092ec790df5d2b4ff37e56acd159c40314,lvgl/lvgl
2,2.0,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0
    lv_mem_ent_t * full = (lv_mem_ent_t *)&work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2017-11-26 11:38:28 +0100,src/lv_misc/lv_mem.c,,c48a521882a7c45a4940aef60718f7decccde486,lvgl/lvgl
3,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0
	work_mem = (uint8_t*) work_mem_int;
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static inline  void lv_mem_assert(void *p),2018-07-25 06:52:59 +0200,src/lv_misc/lv_mem.c,100.0,1b9845e38fb0c7bd8322e3321afccb1ed4dc5470,lvgl/lvgl
4,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0
    work_mem = (uint8_t *) work_mem_int;
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2018-10-05 17:22:49 +0200,src/lv_misc/lv_mem.c,,41695bf9ac758ae3276424e06308e1bb89c4c019,lvgl/lvgl
5,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *) work_mem_int;
#else
    work_mem = (uint8_t *) LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2019-01-28 06:09:06 +0100,src/lv_misc/lv_mem.c,,eca9245382e31922d3af2f2214926be3069c1e21,lvgl/lvgl
6,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0
    work_mem = (uint8_t *) work_mem_int;
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2019-01-28 15:18:59 +0100,src/lv_misc/lv_mem.c,,f5bd68fa776be80e3b8ac385e9548a811fd4334b,lvgl/lvgl
7,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *) work_mem_int;
#else
    work_mem = (uint8_t *) LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2019-01-28 15:18:59 +0100,src/lv_misc/lv_mem.c,,31d0a7f3ae361403c675e55eea556425cff1ca7b,lvgl/lvgl
8,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *) work_mem_int;
#else
    work_mem = (uint8_t *) LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2019-03-15 19:41:54 -0400,src/lv_misc/lv_mem.c,,edb58cc61b1a2ca232a2cd7127194a905de93394,lvgl/lvgl
9,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",,2019-04-04 07:15:40 +0200,src/lv_misc/lv_mem.c,,ba2160042a3b61787c3c57c4b4cca210e3dee308,lvgl/lvgl
10,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-05-13 14:11:16 +0200,src/lv_misc/lv_mem.c,118,97392f4fdf0566583cf67e5d6842f4d7528fe830,lvgl/lvgl
11,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-06-08 20:22:06 +0100,src/lv_misc/lv_mem.c,119,0ebcf7e26612d77903d1a7dbefbef9f8c16a6b14,lvgl/lvgl
12,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-06-15 17:12:48 +0300,src/lv_misc/lv_mem.c,119,585bc329e68a760f41e1d577dda67b901c2fc776,lvgl/lvgl
13,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-06-18 06:40:39 -0400,src/lv_misc/lv_mem.c,122,25fbcea31ac448917d8dbeb35d5f5077397ed81d,lvgl/lvgl
14,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-07-07 09:36:59 +0200,src/lv_misc/lv_mem.c,122,43f5e4d2e0bfe140b37297ac165d40d398052e77,lvgl/lvgl
15,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-08-31 09:33:44 +0200,src/lv_misc/lv_mem.c,122,67d268b3ee114817fb5d6902dc3c52ff01540ace,lvgl/lvgl
16,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-11-25 12:21:22 -0500,src/lv_misc/lv_mem.c,122,d6dd6199f31e515a8cf93626bdb12abc5d2263c3,lvgl/lvgl
17,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2020-12-11 18:04:23 +0100,src/lv_misc/lv_mem.c,124,ec124559f651f045a31ab1167d4be719bb493491,lvgl/lvgl
18,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-01-11 14:28:00 +0100,src/lv_misc/lv_mem.c,122,81b13bf3b6219c3b1b05b05209a8449abf7ab84b,lvgl/lvgl
19,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-01-12 19:26:26 +0100,src/lv_misc/lv_mem.c,119,bc25998c5b2acc347eade7d3dac29675d81476b8,lvgl/lvgl
20,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-01-21 15:18:20 +0100,src/lv_misc/lv_mem.c,124,1d6d2eb9d94080db9b5ff2855334b5895df28e52,lvgl/lvgl
21,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
    mem_max_size = 0;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-01-23 20:46:42 +0100,src/lv_misc/lv_mem.c,124,ea6ee3d19818ce61545ef4b1cbbdc6f537aa6701,lvgl/lvgl
22,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-01-26 14:12:35 +0100,src/lv_misc/lv_mem.c,121,07268829c44cb7b040221a2e405dbb2f10289b40,lvgl/lvgl
23,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-02-04 14:46:11 +0100,src/lv_misc/lv_mem.c,121,8a1af8646f2eb7a4be232e7fa7570c65b46185ba,lvgl/lvgl
24,,"void _lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}

",static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-02-19 13:56:59 +0100,src/lv_misc/lv_mem.c,120,06917a6ec3bfdf12b19aede3e6df06e66d681ed7,lvgl/lvgl
25,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif
    last_mem = &work_mem[LV_MEM_SIZE - 1];
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif

#if LV_MEM_ADD_JUNK
    LV_LOG_WARN(""LV_MEM_ADD_JUNK is enabled which makes LVGL much slower"")
#endif
}

",static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];,2021-02-24 10:07:54 +0100,src/lv_misc/lv_mem.c,121,8004058463a8d4a71f47910e3c6c93653d4f7c50,lvgl/lvgl
26,,"void lv_mem_init(void)
{
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    tlsf = tlsf_create_with_pool((void *)work_mem_int, LV_MEM_SIZE);
#else
    tlsf = tlsf_create_with_pool((void *)LV_MEM_ADR, LV_MEM_SIZE);
#endif
#endif

#if LV_MEM_ADD_JUNK
    LV_LOG_WARN(""LV_MEM_ADD_JUNK is enabled which makes LVGL much slower"")
#endif
}

",,2021-03-10 15:13:35 +0100,src/lv_misc/lv_mem.c,,7bf547a9280973e96a21ff9b5165f69051f60c19,lvgl/lvgl
